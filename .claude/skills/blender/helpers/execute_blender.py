#!/usr/bin/env python3
"""
Execute a Blender Python script and generate multi-view renders.
Standalone helper for the Blender skill - minimal dependencies.

Usage:
    python execute_blender.py <script_path> <output_dir>

Environment Variables:
    BLENDER_PATH: Path to Blender executable (default: "blender")
"""

import sys
import json
import subprocess
import os
from pathlib import Path
from datetime import datetime


def main():
    if len(sys.argv) < 3:
        print(json.dumps({
            "status": "error",
            "message": "Usage: execute_blender.py <script_path> <output_dir>"
        }))
        sys.exit(1)

    script_path = Path(sys.argv[1])
    output_dir = Path(sys.argv[2])

    if not script_path.exists():
        print(json.dumps({
            "status": "error",
            "message": f"Script not found: {script_path}"
        }))
        sys.exit(1)

    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)
    render_dir = output_dir / "renders"
    render_dir.mkdir(exist_ok=True)

    # Prepare full script with rendering
    try:
        user_code = script_path.read_text()
        full_script = prepare_script(
            user_code,
            blend_path=output_dir / "model.blend",
            render_dir=render_dir
        )
    except Exception as e:
        print(json.dumps({
            "status": "error",
            "message": f"Failed to prepare script: {str(e)}"
        }))
        sys.exit(1)

    temp_script = output_dir / "full_script.py"
    temp_script.write_text(full_script)

    # Execute Blender
    blender_path = os.environ.get("BLENDER_PATH", "blender")
    result = run_blender(blender_path, temp_script, output_dir / "blender.log")

    if not result.get("success"):
        print(json.dumps(result))
        sys.exit(1)

    # Post-process renders (create grid and GIF)
    try:
        # Import here to avoid dependency issues if PIL/imageio not installed
        sys.path.insert(0, str(Path(__file__).parent))
        from renderer import RenderManager

        rm = RenderManager()

        # Create grid
        views = ["front", "top", "side", "iso"]
        view_paths = [render_dir / f"view_{v}.png" for v in views]
        existing_views = [p for p in view_paths if p.exists()]

        grid_path = None
        if len(existing_views) >= 4:
            grid_path = render_dir / "grid_4view.png"
            rm.create_grid_image(existing_views[:4], grid_path, labels=views)

        # Create GIF
        gif_path = None
        turntable_dir = render_dir / "turntable_frames"
        if turntable_dir.exists():
            gif_path = render_dir / "turntable.gif"
            rm.create_turntable_gif(turntable_dir, gif_path)

    except ImportError as e:
        # PIL or imageio not available - skip post-processing
        grid_path = None
        gif_path = None
        print(f"[WARNING] Post-processing skipped: {e}", file=sys.stderr)

    # Return paths
    output = {
        "status": "success",
        "blend_file": str(output_dir / "model.blend"),
        "renders": {
            "front": str(render_dir / "view_front.png"),
            "top": str(render_dir / "view_top.png"),
            "side": str(render_dir / "view_side.png"),
            "iso": str(render_dir / "view_iso.png"),
        },
        "grid": str(grid_path) if grid_path and grid_path.exists() else None,
        "turntable": str(gif_path) if gif_path and gif_path.exists() else None,
        "output_dir": str(output_dir)
    }

    print(json.dumps(output, indent=2))
    sys.exit(0)


def prepare_script(user_code, blend_path, render_dir):
    """Inject header and render code into user script."""
    from render_template import RENDER_TEMPLATE

    header = f'''# Generated by Blender Skill - {datetime.now().isoformat()}
import bpy
import math
import os

# Output paths (injected by executor)
OUTPUT_BLEND_PATH = r"{blend_path}"
OUTPUT_DIR = r"{render_dir}"
RENDER_RESOLUTION = (512, 512)

'''

    # Remove duplicate imports from user code
    lines = []
    for line in user_code.split('\n'):
        stripped = line.strip()
        if stripped.startswith('import bpy'):
            continue
        if stripped.startswith('import math'):
            continue
        if stripped.startswith('import os'):
            continue
        lines.append(line)

    clean_code = '\n'.join(lines)
    return header + clean_code + '\n\n' + RENDER_TEMPLATE


def run_blender(blender_path, script_path, log_path):
    """Execute Blender with timeout protection."""
    cmd = [str(blender_path), "--background", "--python", str(script_path)]

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=90,
            env={**os.environ, "PYTHONDONTWRITEBYTECODE": "1"}
        )

        # Save logs
        with open(log_path, 'w') as f:
            f.write("=== STDOUT ===\n")
            f.write(result.stdout)
            f.write("\n=== STDERR ===\n")
            f.write(result.stderr)

        if result.returncode != 0:
            return {
                "status": "error",
                "message": f"Blender exited with code {result.returncode}",
                "error": result.stderr[-500:] if result.stderr else "Unknown error",
                "log_path": str(log_path)
            }

        # Check for Python errors in stderr
        if "Traceback" in result.stderr or "Error:" in result.stderr:
            return {
                "status": "error",
                "message": "Blender script had errors",
                "error": extract_error(result.stderr),
                "log_path": str(log_path)
            }

        return {"success": True}

    except subprocess.TimeoutExpired:
        return {
            "status": "error",
            "message": "Blender execution timed out after 90s",
            "fix": "Simplify the script or reduce modifier complexity"
        }
    except FileNotFoundError:
        return {
            "status": "error",
            "message": f"Blender executable not found: {blender_path}",
            "fix": "Set BLENDER_PATH environment variable or install Blender"
        }


def extract_error(stderr):
    """Extract relevant error from stderr."""
    lines = stderr.strip().split('\n')
    for i, line in enumerate(lines):
        if line.startswith("Traceback"):
            # Return traceback + next 10 lines
            return '\n'.join(lines[i:min(i+10, len(lines))])
    # No traceback, return last 10 lines
    return '\n'.join(lines[-10:])


if __name__ == "__main__":
    main()
