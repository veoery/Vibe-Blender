#!/usr/bin/env python3
"""
Execute a Blender Python edit script on an existing .blend file.
Renders using existing Camera1/Camera2 for BlenderBench evaluation.

Usage:
    python execute_blender_edit.py <script_path> <blend_file_path> <output_dir> [--num-renders N]

Environment Variables:
    BLENDER_PATH: Path to Blender executable (default: "blender")

Output:
    - render1.png (from Camera1)
    - render2.png (from Camera2, if --num-renders >= 2)
    - model.blend (modified scene)
    - blender.log (execution log)
"""

import sys
import json
import subprocess
import os
import argparse
from pathlib import Path
from datetime import datetime


def main():
    parser = argparse.ArgumentParser(description="Execute Blender edit script")
    parser.add_argument("script_path", type=Path, help="Path to the edit script")
    parser.add_argument("blend_file_path", type=Path, help="Path to the .blend file")
    parser.add_argument("output_dir", type=Path, help="Output directory")
    parser.add_argument(
        "--num-renders",
        type=int,
        default=1,
        help="Number of renders to generate (matches goal image count)",
    )

    args = parser.parse_args()

    script_path = args.script_path
    blend_file_path = args.blend_file_path
    output_dir = args.output_dir
    num_renders = args.num_renders

    # Validate inputs
    if not script_path.exists():
        print(json.dumps({"status": "error", "message": f"Script not found: {script_path}"}))
        sys.exit(1)

    if not blend_file_path.exists():
        print(
            json.dumps({"status": "error", "message": f"Blend file not found: {blend_file_path}"})
        )
        sys.exit(1)

    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)
    render_dir = output_dir / "renders"
    render_dir.mkdir(exist_ok=True)

    # Prepare full script with rendering
    try:
        user_code = script_path.read_text()
        full_script = prepare_edit_script(
            user_code,
            blend_file_path=blend_file_path,
            output_blend_path=output_dir / "model.blend",
            render_dir=render_dir,
            num_renders=num_renders,
        )
    except Exception as e:
        print(json.dumps({"status": "error", "message": f"Failed to prepare script: {str(e)}"}))
        sys.exit(1)

    temp_script = output_dir / "full_script.py"
    temp_script.write_text(full_script)

    # Execute Blender
    blender_path = os.environ.get("BLENDER_PATH", "blender")
    result = run_blender(blender_path, temp_script, output_dir / "blender.log")

    if not result.get("success"):
        print(json.dumps(result))
        sys.exit(1)

    # Check what renders were generated (only up to num_renders)
    renders = {}
    for i in range(1, num_renders + 1):
        render_path = render_dir / f"render{i}.png"
        if render_path.exists():
            renders[f"render{i}"] = str(render_path)

    output = {
        "status": "success",
        "blend_file": str(output_dir / "model.blend"),
        "renders": renders,
        "output_dir": str(output_dir),
        "render_dir": str(render_dir),
        "num_renders": num_renders,
    }

    print(json.dumps(output, indent=2))
    sys.exit(0)


def prepare_edit_script(user_code, blend_file_path, output_blend_path, render_dir, num_renders=1):
    """Inject header and render code into user edit script."""
    from eval_render_template import EVAL_RENDER_TEMPLATE

    header = f'''# Generated by Blender Edit Skill - {datetime.now().isoformat()}
import bpy
import math
import os

# Paths (injected by executor)
BLEND_FILE_PATH = r"{blend_file_path}"
OUTPUT_BLEND_PATH = r"{output_blend_path}"
OUTPUT_DIR = r"{render_dir}"
RENDER_RESOLUTION = (512, 512)
RENDER_SAMPLES = 64
NUM_RENDERS = {num_renders}  # Match number of goal images

'''

    # Remove duplicate imports from user code
    lines = []
    for line in user_code.split("\n"):
        stripped = line.strip()
        if stripped.startswith("import bpy"):
            continue
        if stripped.startswith("import math"):
            continue
        if stripped.startswith("import os"):
            continue
        lines.append(line)

    clean_code = "\n".join(lines)

    # Combine: header + user edit code + render template
    return header + clean_code + "\n\n" + EVAL_RENDER_TEMPLATE


def run_blender(blender_path, script_path, log_path):
    """Execute Blender with timeout protection."""
    cmd = [str(blender_path), "--background", "--python", str(script_path)]

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=180,  # 3 minutes for higher sample count
            env={**os.environ, "PYTHONDONTWRITEBYTECODE": "1"},
        )

        # Save logs
        with open(log_path, "w") as f:
            f.write("=== STDOUT ===\n")
            f.write(result.stdout)
            f.write("\n=== STDERR ===\n")
            f.write(result.stderr)

        if result.returncode != 0:
            return {
                "status": "error",
                "message": f"Blender exited with code {result.returncode}",
                "error": result.stderr[-1000:] if result.stderr else "Unknown error",
                "log_path": str(log_path),
            }

        # Check for Python errors in stderr
        if "Traceback" in result.stderr or "Error:" in result.stderr:
            return {
                "status": "error",
                "message": "Blender script had errors",
                "error": extract_error(result.stderr),
                "log_path": str(log_path),
            }

        return {"success": True}

    except subprocess.TimeoutExpired:
        return {
            "status": "error",
            "message": "Blender execution timed out after 180s",
            "fix": "Scene may be too complex or GPU not available",
        }
    except FileNotFoundError:
        return {
            "status": "error",
            "message": f"Blender executable not found: {blender_path}",
            "fix": "Set BLENDER_PATH environment variable or install Blender",
        }


def extract_error(stderr):
    """Extract relevant error from stderr."""
    lines = stderr.strip().split("\n")
    for i, line in enumerate(lines):
        if line.startswith("Traceback"):
            # Return traceback + next 15 lines
            return "\n".join(lines[i : min(i + 15, len(lines))])
    # No traceback, return last 15 lines
    return "\n".join(lines[-15:])


if __name__ == "__main__":
    main()
